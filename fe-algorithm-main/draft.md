# algorithm
前端啃算法


​

[1,2,3,4,5]
​

1=>2=>3=>4
​

数据结构的增删改查


arr[0]  arr[1]  随机访问 O(1)
​

[1 ,2,3,6,4,5] 新增元素复杂度是O(n)
​

​

链表：
 ----->
1    2       3=>4  =7=>5=>6
随机访问的复杂度是O(n) 
删除 和插入元素复杂度都是O1





搜索 排序，都是基础问题

排序算法：如何把一个数组变成有序的
arr = [3,2,1,4]
增删改查几个操作 
冒泡排序





排序
二分
递归
回溯
贪心
动态规划


全排列
  <!-- 1,2,3 这三个数字，打印全部的排列情况

  [3,2,] -->

1. 需要全部答案的路径
```
let list = []
function backtrack(list,临时路径,输入){

  结束条件：
    临时路径.新增一个路径

  循环{
    选择一个数据 （选择其他数据）
    递归  backtrack(list,临时路径,输入)
    撤回选择的数据
  }
}

backtrack(list)

```

2 不需要全部路径，只需要true或者false







## 贪心
每一步都选择当前最优解，跟之前的选择没关系
1. 找零钱（最少的张数）
   1. 100,50,20,10,5,1(无限)
   2. 每一次都可以按照这个当前能找的最大值 最终能够得出全局最后解 （没有反例）

## 动态规划  递推公式
求极值
每一步的状态，是前一步推导而来

<!-- 走迷宫 每一步都有数字，怎么走能够数字最小
   2    100     10
1  3    6       9
   4    7       3

走每一步 都保存一个不同状态的最优解 -->

菲波那切数列 
[0,1,1,2,3,5,8,13....]

dp[i] 中间值的推导
确定推导的公式
确定初始化 和遍历顺序

Vue中的虚拟dom diff 最长递增子序列 （刷题）